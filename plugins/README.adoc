= Plugins good practices

NOTE: Work in Progress...

== Python Guidelines

* Review Ansible guidelines for https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_best_practices.html[modules] and https://docs.ansible.com/ansible/latest/dev_guide/index.html[development].
* Use https://pep8.org/[PEP8].
* File headers and functions should have comments for their intent.


== All plugin types should use argspec validation, inbound and outbound
[%collapsible]
===
Explanations:: A plugin's `argument_spec` (or "argspec") defines the supported arguments for a module, as well as their type, defaults and more.

Rationale:: Validating the argspec at the time that it enters and exits the code ensures that these inputs and outputs conform to the plugin's documentation and the user's expectations.

Examples::
From the https://github.com/ansible-collections/ansible.utils/blob/2.6.0/plugins/filter/ipaddr.py[ipaddr] filter plugin.
[source,python]
----
from ansible_collections.ansible.utils.plugins.module_utils.common.argspec_validate import (
    AnsibleArgSpecValidator,
)


aav = AnsibleArgSpecValidator(
    data=data, schema=DOCUMENTATION, name="ipaddr"
)
valid, errors, updated_data = aav.validate()
if not valid:
    raise AnsibleFilterError(errors)
return ipaddr(**updated_data)
----
====

== All plugin types should have documentation
[%collapsible]
====
Explanations::
All plugins, regardless of type, should have documentation that describes the input parameters, outputs, and practical examples of how to use it.
====

== Use sphinx (reST) formatted docstrings
[%collapsible]
====
Explanations::
All classes, private and public functions should have a sphinx (reST) formatted docstring including all parameters, yields, raises, or returns.

Rationale::
PEP-257 states that all modules should normally have docstrings, and all functions and classes exported by a module should also have docstrings. Public methods (including the __init__ constructor) should also have docstrings. A package may be documented in the module docstring of the __init__.py file in the package directory.

Examples::
[source,python]
----
"""[Summary]

:param [ParamName]: [ParamDescription], defaults to [DefaultParamVal]
:type [ParamName]: [ParamType](, optional)
...
:raises [ErrorType]: [ErrorDescription]
...
:return: [ReturnDescription]
:rtype: [ReturnType]
"""
----

====

== If Python 3 or greater, all code should have type hints and be validated with mypy
[%collapsible]
====
Explanations:: Use Python type hints to document variable types.

Rationale::  Type hints communicate what type a variable can be expected to be in the code. They can be consumed by static analysis tools to ensure that variable usage is consistent within the code base.
MyPy is a static type checker/

Examples::
[source,python]
----
def greeting(name: str) -> str:
    return 'Hello ' + name
----

====

== The use of unittest is discouraged, use pytest instead.
[%collapsible]
====
Explanations:: Use pytest for writing unit tests for plugins

Rationale:: Pytest is the testing framework used by Ansible Engineering and will provide the best experience for plugin developers

Examples::
[source,python]
----
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import pytest

from ansible.modules.copy import AnsibleModuleError, split_pre_existing_dir
from ansible.module_utils.basic import AnsibleModule

ONE_DIR_DATA = (('dir1',
                 ('.', ['dir1']),
                 ('dir1', []),
                 ),
                ('dir1/',
                 ('.', ['dir1']),
                 ('dir1', []),
                 ),
                ) 

@pytest.mark.parametrize('directory, expected', ((d[0], d[2]) for d in ONE_DIR_DATA))
def test_split_pre_existing_dir_one_level_exists(directory, expected, mocker):
    mocker.patch('os.path.exists', side_effect=[True, False, False])
    split_pre_existing_dir(directory) == expected

----

====

== A complex plugin argspec should be derived from its documentation runtime if the plugin’s source is manually maintained.
[%collapsible]
====
Explanations::
A complex plugin argspec should be derived from its documentation runtime if the plugin’s source is manually maintained.  ( >30 keys or depth>2) (action plugins and control node execution modules)

Rationale::
Hand-crafting large and complex argument specifications can be error-prone and difficult to maintain.  Programmatically generating the spec from DOCUMENTATION (already a structured data object) ensures consistency and accuracy. 

====

== Formatting of manually maintained plugin argspecs
[%collapsible]
====
Explanations::
Ensure a consistent approach to the way commplex argument_specs are formatted within a collection.

Rationale::
When hand-writing a complex argspec, the author may choose to build up to data structure from multiple dictionaries or vars.
Other authors may choose to implement a complex, nested argspec as a single dictionary.
Within a single collection, select one style and use it consistently.

Examples::
Single dictionary:
https://github.com/ansible-collections/cisco.nxos/blob/3.0.0/plugins/module_utils/network/nxos/argspec/bgp_global/bgp_global.py

Multiple dictionaries:
https://github.com/ansible-collections/community.aws/blob/stable-3/plugins/modules/ec2_scaling_policy.py#L355-L370
https://github.com/ansible-collections/amazon.cloud/blob/0.1.0/plugins/modules/backup_report_plan.py#L182-L234
====


== A plugin’s entry file should not contain more than 500 lines
[%collapsible]
====
Explanations::
A plugin’s entry file should not contain more than 500 lines

Rationale::
Long and complex code files can be difficult to maintain.
Wherever possible, reusable functions and classes, such as those for data validation or manipulation, should be moved to module_utility or plugin_utility files and imported into plugins.
This keeps the plugin code easier to read and maintain.
500 lines is a general guideline that should serve most cases.
====

== Action plugins should be used when the code runs on the control node.
[%collapsible]
====
Explanations::
Use an action plugin for code that needs to run on the controller, where the host would be `localhost`.
Rationale::
Action plugins let you integrate local processing and local data with module functionality.
Action plugins act in conjunction with modules to execute the actions required by playbook tasks.
Using an action plugin will cause Ansible to skip creating a temporary tarball of execution code and runs the code directly on the controller host.

Examples::
See the `ansible.snmp.get` https://github.com/ansible-network/ansible.snmp/blob/main/plugins/action/get.py[action plugin] and associated https://github.com/ansible-network/ansible.snmp/blob/main/plugins/modules/get.py[module].

====

== Design decisions accounting for “jump hosts” should be avoided.
[%collapsible]
====
Explanations::
A plugin should be developed in accordance with Ansible best practices, without accounting for possible environment-specific variables.

Rationale::
The plugin author should prioritize development of the plugin's function.
If an environment that the plugin could possibly run in (such as on a jump host) has some unique property this should be managed by the operator's Ansible configuration, separate from the plugin code.

====

== Plugins should be initially developed using the ansible plugin builder
[%collapsible]
====
Explanations::
The https://github.com/ansible-community/ansible.plugin_builder[ansible.plugin_builder] is a tool which helps developers scaffold new plugins.

====

== Pylint and type exceptions should have a specific exclusion type
[%collapsible]
====
Explanations::
Pylint and type exceptions should only be used when required due to bugs or 3rd party package requirements. All should have a specific exclusion type.

Rationale::
Linting and type exceptions should not be used except where the logic of the code absolutely requires it.

Examples::
[source,python]
----
            if not rule.get('group_desc', '').strip():
                # retry describing the group once
                try:
                    auto_group = get_security_groups_with_backoff(client, Filters=ansible_dict_to_boto3_filter_list(filters)).get('SecurityGroups', [])[0]
                except (is_boto3_error_code('InvalidGroup.NotFound'), IndexError):
                    module.fail_json(msg="group %s will be automatically created by rule %s but "
                                         "no description was provided" % (group_name, rule))
                except ClientError as e:  # pylint: disable=duplicate-except
                    module.fail_json_aws(e)
----


====

== Plugins for applicance configuration should follow the Resource Module pattern (see below)
[%collapsible]
====
Explanations:: Resource modules allow the user to manage resources on an appliance (such as a network or security device) without having to write complex Jinja templates.

Rationale:: Resource modules allow the user to manage resources on an appliance (such as a network or security device) without having to write complex Jinja templates.

Examples::
https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html

====

== Use clear error/info messages
[%collapsible]
====
Explanations:: This will make it easier to troubleshoot failures if they occur

Rationale:: Error messages that communicate specific details of the failure will aid in resolving the problem.
Unclear error messages such as "Failed!" are unnecessarily obscure.

Examples::
[source,python]
----
    if checksum and checksum_src != checksum:
        module.fail_json(
            msg='Copied file does not match the expected checksum. Transfer failed.',
            checksum=checksum_src,
            expected_checksum=checksum
        )
----

====
