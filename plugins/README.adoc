= Plugins good practices

NOTE: Work in Progress...

== Python Guidelines

* Review Ansible guidelines for https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_best_practices.html[modules] and https://docs.ansible.com/ansible/latest/dev_guide/index.html[development].
* Use https://pep8.org/[PEP8].
* File headers and functions should have comments for their intent.


== Use argspec validation, inbound and outbound, for all plugin types
[%collapsible]
===
Explanations:: A plugin's `argument_spec` (or "argspec") defines the supported arguments for a module, as well as their type, defaults and more.

Rationale:: Validating the argspec at the time that it enters and exits the code ensures that these inputs and outputs conform to the plugin's documentation and the user's expectations.

Examples::
From the https://github.com/ansible-collections/ansible.utils/blob/2.6.0/plugins/filter/ipaddr.py[ipaddr] filter plugin.
[source,python]
----
from ansible_collections.ansible.utils.plugins.module_utils.common.argspec_validate import (
    AnsibleArgSpecValidator,
)


aav = AnsibleArgSpecValidator(
    data=data, schema=DOCUMENTATION, name="ipaddr"
)
valid, errors, updated_data = aav.validate()
if not valid:
    raise AnsibleFilterError(errors)
return ipaddr(**updated_data)
----
====

== Write documentation for all plugin types
[%collapsible]
====
Explanations::
All plugins, regardless of type, need documentation that describes the input parameters, outputs, and practical examples of how to use it.

Examples:: See the Ansible Developer Guide sections on https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#plugin-configuration-documentation-standards[Plugin Configuration and Documentation Standards] and https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_documenting.html#module-documenting[Module Documentating] for more details.
====

== Use sphinx (reST) formatted docstrings in Python code
[%collapsible]
====
Explanations::
Sphinx (reST) formatted docstring are preferred for Ansible development. This includes all parameters, yields, raises, or returns for all classes, private and public functions.

Rationale::
https://peps.python.org/pep-0257/[PEP-257] states that: "All modules should normally have docstrings, and all functions and classes exported by a module should also have docstrings. Public methods (including the __init__ constructor) should also have docstrings. A package may be documented in the module docstring of the __init__.py file in the package directory."

Examples::
[source,python]
----
"""[Summary]

:param [ParamName]: [ParamDescription], defaults to [DefaultParamVal]
:type [ParamName]: [ParamType](, optional)
...
:raises [ErrorType]: [ErrorDescription]
...
:return: [ReturnDescription]
:rtype: [ReturnType]
"""
----

====

== Use Python type hints to document variable types.
[%collapsible]
====
Explanations:: Use Python type hints to document variable types.  Type hints are supported in Python 3.5 and greater.

Rationale::  Type hints communicate what type a variable can be expected to be in the code. They can be consumed by static analysis tools to ensure that variable usage is consistent within the code base.

Examples::
[source,python]
MyPy is a static type checker, which could analyze the following snippet:
----
def greeting(name: str) -> str:
    return 'Hello ' + name
----

====

== The use of unittest is discouraged, use pytest instead.
[%collapsible]
====
Explanations:: Use https://docs.pytest.org/[pytest] for writing unit tests for plugins

Rationale:: Pytest is the testing framework used by Ansible Engineering and will provide the best experience for plugin developers

Examples::
[source,python]
----
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import pytest

from ansible.modules.copy import AnsibleModuleError, split_pre_existing_dir
from ansible.module_utils.basic import AnsibleModule

ONE_DIR_DATA = (('dir1',
                 ('.', ['dir1']),
                 ('dir1', []),
                 ),
                ('dir1/',
                 ('.', ['dir1']),
                 ('dir1', []),
                 ),
                ) 

@pytest.mark.parametrize('directory, expected', ((d[0], d[2]) for d in ONE_DIR_DATA))
def test_split_pre_existing_dir_one_level_exists(directory, expected, mocker):
    mocker.patch('os.path.exists', side_effect=[True, False, False])
    split_pre_existing_dir(directory) == expected

----

====

== A complex plugin argspec should be derived from its documentation runtime if the plugin’s source is manually maintained.
[%collapsible]
====
Explanations::
A complex plugin argspec should be derived from its documentation runtime if the plugin’s source is manually maintained.  ( >30 keys or depth>2) (action plugins and control node execution modules)

Rationale::
Hand-crafting large and complex argument specifications can be error-prone and difficult to maintain.  Programmatically generating the spec from DOCUMENTATION (already a structured data object) ensures consistency and accuracy. 

====

== Formatting of manually maintained plugin argspecs
[%collapsible]
====
Explanations::
Ensure a consistent approach to the way commplex argument_specs are formatted within a collection.

Rationale::
When hand-writing a complex argspec, the author may choose to build up to data structure from multiple dictionaries or vars.
Other authors may choose to implement a complex, nested argspec as a single dictionary.
Within a single collection, select one style and use it consistently.

Examples::
Use of a https://github.com/ansible-collections/cisco.nxos/blob/3.0.0/plugins/module_utils/network/nxos/argspec/bgp_global/bgp_global.py[sngle dictionary]

Two different examples of using https://github.com/ansible-collections/community.aws/blob/stable-3/plugins/modules/ec2_scaling_policy.py#L355-L370[multiple] https://github.com/ansible-collections/amazon.cloud/blob/0.1.0/plugins/modules/backup_report_plan.py#L182-L234[dictionaries].
====


== Keep plugin entry files to a minimal size.
[%collapsible]
====
Explanations::
Keep the entry file to a plugin to a minimal and easily maintainable size.

Rationale::
Long and complex code files can be difficult to maintain.
Move reusable functions and classes, such as those for data validation or manipulation, to a https://docs.ansible.com/ansible/latest/dev_guide/developing_module_utilities.html[module_utils/] (for Ansible modules) or plugin_utils/ (for all other plugin types) file and import them into plugins.
This keeps the Python code easier to read and maintain.
====

== Action plugins should be used when the code runs on the control node.
[%collapsible]
====
Explanations::
Use an action plugin for code that needs to run on the controller, where the host would be `localhost`.
Rationale::
Action plugins let you integrate local processing and local data with module functionality.
Action plugins act in conjunction with modules to execute the actions required by playbook tasks.
Using an action plugin will cause Ansible to skip creating a temporary tarball of execution code and runs the code directly on the controller host.

Examples::
See the `ansible.snmp.get` https://github.com/ansible-network/ansible.snmp/blob/main/plugins/action/get.py[action plugin] and associated https://github.com/ansible-network/ansible.snmp/blob/main/plugins/modules/get.py[module].

====

== Design decisions accounting for “jump hosts” should be avoided.
[%collapsible]
====
Explanations::
A plugin should be developed in accordance with Ansible best practices, without accounting for possible environment-specific variables.

Rationale::
The plugin author should prioritize development of the plugin's function.
If an environment that the plugin could possibly run in (such as on a jump host) has some unique property this should be managed by the operator's Ansible configuration, separate from the plugin code.

====

== Plugins should be initially developed using the ansible plugin builder
[%collapsible]
====
Explanations::
The https://github.com/ansible-community/ansible.plugin_builder[ansible.plugin_builder] is a tool which helps developers scaffold new plugins.

====

== Pylint and type exceptions should have a specific exclusion type
[%collapsible]
====
Explanations::
Pylint and type exceptions should only be used when required due to bugs or 3rd party package requirements. All should have a specific exclusion type.

Rationale::
Linting and type exceptions should not be used except where the logic of the code absolutely requires it.

Examples::
[source,python]
----
            if not rule.get('group_desc', '').strip():
                # retry describing the group once
                try:
                    auto_group = get_security_groups_with_backoff(client, Filters=ansible_dict_to_boto3_filter_list(filters)).get('SecurityGroups', [])[0]
                except (is_boto3_error_code('InvalidGroup.NotFound'), IndexError):
                    module.fail_json(msg="group %s will be automatically created by rule %s but "
                                         "no description was provided" % (group_name, rule))
                except ClientError as e:  # pylint: disable=duplicate-except
                    module.fail_json_aws(e)
----


====

== Plugins for applicance configuration should follow the Resource Module pattern (see below)
[%collapsible]
====
Explanations:: Resource modules allow the user to manage resources on an appliance (such as a network or security device) without having to write complex Jinja templates.

Rationale:: Resource modules allow the user to manage resources on an appliance (such as a network or security device) without having to write complex Jinja templates.

Examples::
https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html

====

== Use clear error/info messages
[%collapsible]
====
Explanations:: This will make it easier to troubleshoot failures if they occur

Rationale:: Error messages that communicate specific details of the failure will aid in resolving the problem.
Unclear error messages such as "Failed!" are unnecessarily obscure.

Examples::
[source,python]
----
    if checksum and checksum_src != checksum:
        module.fail_json(
            msg='Copied file does not match the expected checksum. Transfer failed.',
            checksum=checksum_src,
            expected_checksum=checksum
        )
----

====
